---
alwaysApply: true
---

# Create PRP (Advanced Implementation Focus)

## Feature file: $ARGUMENTS

Generate a complete PRP for general feature implementation with thorough research. Ensure context is passed to the AI agent to enable self-validation and iterative refinement. Read the feature file first to understand what needs to be created, how the examples provided help, and any other considerations.

The AI agent only gets the context you append to the PRP and its training data. Assume the AI agent has access to the codebase and a similar knowledge cutoff, so include or reference research findings directly in the PRP. The Agent has web search capabilities—pass URLs to documentation and examples.

## Core PRP Creation Workflow

1. **Read INITIAL.md first** – Parse project context and requirements
2. **Analyze codebase** – Understand existing patterns and structure
3. **Generate PRP** – Use canonical template structure with implementation focus
4. **Validate context** – Ensure all necessary information is included
5. **Review and refine** – Iterate until PRP is implementation-ready

## Research Process

1. **Codebase Analysis**
   - Search for similar features/patterns in the codebase
   - Identify files to reference in the PRP
   - Note existing conventions to follow
   - Check test patterns for validation approach

2. **External Research**
   - Search for similar features/patterns online
   - Library documentation (include specific URLs)
   - Implementation examples (GitHub/StackOverflow/blogs)
   - Best practices and common pitfalls

3. **User Clarification** (if needed)
   - Specific patterns to mirror and where to find them?
   - Integration requirements and where to find them?

## PRP Generation

Using the canonical template structure from `assets/agent-kit/PRP-template/prp.template.json`:

### Required Sections (ALL must be present)

- **goal** – Specific, measurable feature goal with deliverable
- **why** – Business value, integration benefits, problem solving
- **what** – User-visible behavior and technical requirements
- **context** – Documentation, references, codebase analysis, principles, trees
- **implementation_blueprint** – Phases, tasks, patterns, integration
- **validation** – 4-level validation system with final checklist and summary

### All Needed Context to include (and pass to the AI agent)

- **context.current_tree** – Current codebase structure (run `tree` command)
- **context.desired_tree** – Target structure with file responsibilities
- **context.documentation** – URLs with specific sections and why
- **context.existing_code** – Real snippets from the codebase with file paths
- **context.gotchas** – Library quirks, version issues, anti-patterns
- **context.principles** – Context engineering principles to follow
- **context.dependencies** – Required packages and services
- **context.environment_variables** – Configuration needed
- **context.config_notes** – Setup and configuration guidance

### Implementation Blueprint

- Start with pseudocode showing the approach
- Reference real files for patterns
- Include an error handling strategy
- List tasks to fulfill the PRP in execution order

Task structure standard:

```yaml
Task N: [ACTION] [file_path]
  - IMPLEMENT: [Specific implementation details]
  - FOLLOW pattern: [exact file path and pattern description]
  - NAMING: [Naming conventions to follow]
  - DEPENDENCIES: [What must be completed first]
  - PLACEMENT: [Where in codebase this goes]
```

Pattern documentation (for each referenced pattern):
- Exact file path
- Specific method/class to follow
- Key implementation details
- Gotchas and limitations
- Integration requirements

### Validation (4 Levels + Final)

- **level_1_syntax** – Syntax, style, type checking commands
- **level_2_unit_tests** – Unit test commands and coverage requirements
- **level_3_integration** – Integration test commands
- **level_4_end_to_end** – End-to-end and creative validation
- **final_checklist** – Comprehensive completion checklist
- **summary** – Confidence score and implementation notes

Executable gates (example for Python):

```bash
# Syntax/Style
ruff check --fix && mypy .

# Unit Tests
uv run pytest tests/ -v
```

**CRITICAL: After researching and exploring the codebase, ULTRATHINK about the PRP and plan your approach BEFORE writing it.**

## Integration with Archon Workflow

When using with Archon CE Template:
1. Language detection from `INITIAL.md` drives template adaptation
2. Workflow scripts ensure proper sequence
3. Canonical template provides implementation precision
4. Cursor rules enhance IDE integration
5. Validation loops ensure quality at each step

## Example PRP Structure

```json
{
  "goal": "Implement user authentication service with JWT tokens",
  "why": [
    "Enable secure user access to protected routes",
    "Provide standardized authentication across the application"
  ],
  "what": {
    "description": "FastAPI authentication endpoints with JWT token management",
    "success_criteria": [
      "Users can register and login successfully",
      "Protected routes require valid JWT tokens",
      "Token refresh mechanism works correctly"
    ],
    "user_stories": [
      "As a user, I want to register so that I can access the application"
    ]
  },
  "context": {
    "documentation": [
      {"source": "https://fastapi.tiangolo.com/tutorial/security/", "why": "FastAPI security patterns"}
    ],
    "existing_code": [
      {"file": "src/models/user.py", "purpose": "User model pattern to follow"}
    ],
    "gotchas": [
      "JWT tokens must have proper expiration handling",
      "Password hashing must use secure algorithms"
    ]
  },
  "implementation_blueprint": {
    "phase_1_foundation": {
      "description": "Set up authentication models and dependencies",
      "tasks": [
        {
          "title": "Create auth models",
          "details": "UserRequest, UserResponse Pydantic models",
          "files": ["src/models/auth_models.py"]
        }
      ]
    }
  },
  "validation": {
    "level_1_syntax": ["ruff check src/", "mypy src/"],
    "level_2_unit_tests": ["pytest tests/ -v"],
    "level_3_integration": ["uvicorn app.main:app --port 8000"],
    "level_4_end_to_end": ["Test full auth flow with curl"],
    "final_checklist": [
      "All endpoints respond correctly",
      "JWT tokens work as expected"
    ],
    "summary": {
      "confidence_score": "9/10",
      "notes": "High confidence with clear patterns and validation"
    }
  }
}
```

## Error Handling Guidance

If context is incomplete:
1. Stop generation immediately
2. Request missing information from the user
3. Suggest specific additions to `INITIAL.md`
4. Resume only when context is complete

If patterns are unclear:
1. Analyze existing codebase for patterns
2. Document discovered patterns in the PRP
3. Reference specific files and methods
4. Include gotchas and limitations

## Output

Save as: `PRPs/{feature-name}.md` (markdown format) or `PRPs/{feature-name}.json` (JSON format)

## Success Metrics

The PRP is ready when:
- All sections are complete and specific
- Implementation tasks are actionable
- Pattern references are exact
- Validation loops are comprehensive
- Context completeness is verified
- Anti-patterns are documented

Generated PRP enables:
- One-pass implementation success
- Clear development roadmap
- Comprehensive testing strategy
- Quality assurance at each step
- Pattern consistency across the codebase

## Quality Checklist

- [ ] All required sections present
- [ ] Context completeness validated (current/desired trees, docs, patterns)
- [ ] Implementation tasks are specific and actionable
- [ ] Pattern references include exact file paths
- [ ] Validation loop defined with executable gates
- [ ] Anti-patterns clearly documented
- [ ] Error handling strategy documented
- [ ] Clear implementation path

Score the PRP on a scale of 1–10 (confidence level to succeed in one-pass implementation using Claude Code).

Remember: The goal is one-pass implementation success through comprehensive context.